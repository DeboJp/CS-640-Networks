# Lecture 1:
    - Building blocks - nodes and links: links connect any 2 nodes.
        - Scaling problem (N2) wires(connections from all) or one wire(every connect to one) we dont do either: 
            we connect nodes to larger router, and routers are connected - more feasible.
        - Google Search: Host -> query -> internet -> Google Serives- runs on Hosts(Googles' Data centers, etc.)
            the arrows are communication links - a physical media that carries data.
            the internet is a network of networks: how to connect multiple hosts, we use routers and switches.
        ISP: Internet Service Providers - a vendor that offers internet connected services(ISPs talk to each other 
        as well and each handles a network of networks).
        
        Protocols: defines order and format of messages for communication between devices.  Things like encrypting, bits conversion, secure, etc.

        Computer network: A SYSTEM htat provides cross-host commpunication for info exchange.

        Design Reqs: connectivity, reasonable correctness(showing up to data version), reasonable Performance, Low cost, reasonable Security. (In order.)

    Whole picture: harware infra, protocols, TOOLS(CDNS, SDNs, middleboxes, caching)
        Infra: harware very old(old school building wires), but why internet still so fast?
        Protocol: navigating traffic, needs wholistic view, similar to maps.
        Performance: throw more infra resources to prolem(mb to gb, etc) + latency problems(artificial workers).
        Cost: low, Security: reasonable.
    Answer? Protocols solve all these?

    Lectures: physical layer, data link layer, IP layer, transport layer, Application (+Security)

# Lecture 2: Layering
    Serives(i.e. google): has client and server, client intiaties contact,reqeuest. server provides a service.

    What is a link exactly, DSL Home network, connects from home cable to telephone company with multiplexer(resrouse usage), given phone line or isp.
        - multiplexing - (1) time division time multiplexing, waits one and prioritizes other
                        (2) parallel multiplexing - frequency division multiplexing. uses a splitter 50 khz to 1mhz for 
                                                    downstream, 4khz to 50 khz for upstream, 0 to 4khz for two-way telephone.
                                                    (distance affects ignal, degree of electrical interference, about 24Mbps-52Mbps downstream)
    Cable link, multiple home cables are connected to a fiber node - a neighborhood junction that support tv signals and network (same concept, 
            freq division multiplexing, Every physical media introduces noise- media impairment, Tv 54 mhz to 500 mhz, network 54 mhz to 1ghz, 40mbps to 1.2gbps down, 30 mbps to 100 mbps up). 

    FTTH home network - Fiber to home, shared connection to company, sharing the cable itself but direct connection to home.

    5G Fixed Wireless - Ethernet - WIFI - 5G mobile network.

    Main idea: need to share resources(each person cannot get their own link), to bring down costs, by multiplexing, freq and wavelenght.

    Q: is the wired shared for cable and dsl as well or did they have their own connections?

    (History) Message Switching: used telegraph lines - could take in data from any direction and send in cardinal direction of destination(were placed in physical hotspots like paris).
                                    called store and forward operations - msgs were decoded, next hop in proper route after reading data.
              Circuit Switching(old analog telephones): Reservation based system, source first establishes a connection(to operator), then swich connections to another user physically. 
                                                            No one else could use the resource at the same time as you. Dedicated service, really reliable and fast performance.
                                                            cons: resource management, not scalable, brusty traffic-what if permanent circuit like facebook.
    Current internet - Packet Switching: Every msg is broken down to packets, break it down to ms intervals. each packet given a source and dest addr. 
                        Jobs of intermediary nodes to passy the packets along. Store and forward.
    Circuit vs Packet Switching - Circuit is predictable performance, low resoursce usage. Packet high utilization, simple but not best for 
                                    extreme reliability but good for bursty traffic.

    PacketSwitching - packets go through switches and routhers to dest. store look and forward devices, takes packets from input ports, looks where to send it, 
                        does some traffic management, queues into buffers and sends to outgoing ports. Needs to wait for entire packet before putting into buffer(limited capacity).
                        L = bits, R = device speed, 3 packets take 4L/R since 1st packet just waits at buffer(introduced 1 time delay).
                        Fixed sized buffer, SRAM static random access memory, fast but hard to scale.
                        Protocols fill in forwarding table, so routers is able to send packet to matching addr's port. also SRAM.

    Circutit: Reservation based. Packet: On-demand

    SOFTWARE PART: 1. Scalable data movement, 2. Reliable bits delivery, 3. Performance maximization, 4. Resource multiplexing, 5. Access control

    Scalability reqs: many users, diverse services/tech, components built by many companies, diverse ownership, mix/match. 
    Key idea some sort of protocol: for scalability between heterogeneous things.

    Solution: connects all services with an intermediate layer(standarized - to address heterogenity). allows new advancements above and below layer independently. all must agree to use it.

        OSI Protocol Stack(the intermediate layer) - Open systems interconnection model, each layer relies on services from layer below and exports services to above layer. interface 
            defines interaction with peer on other hosts - called protocols, standarized. Modules hire implementation layers can change without distrurbign other layers.
                    
            THE STACK: Physical: transmit bits. Data Link: Transmit frames. Network: route packages. Transport: send packets end2end. 
                        Session: how to tie flows together. presentation: byte ordering, security. Application: everything else.
            (Session and presentation not used a much today integrated into app layer, 7 stack becomes 5 stack)

# Lecture 3: Layering + Performance Analysis
    life of packet: host (goes down stack from app to phy) -> Bridge/Switch(physical,data,physical) -> Gateway/Router(phy,data,network,data,physical) -> Host again(up the stack)
    
    a way to make structure for layer is specifying header.
    - each layer is adding some info or implemting their own protocol. (html, connection ID, source/Dest, Link addr <- at each layer)
    - top down from sending side, bottom up from recieveing side.
    - bits, frame, segment, datagram, message are the info the layers take or add, for respective phy, link, network, transport, app layer. Called encapsulation and Decapsulation.

    multiplexing and demux - there may be multikple implementations of each layer.
        - each header includes a demultiplexing field that is used to identify the next layer, filled in my sender and used in reciever.
        - multiplexing occurs at multiple layers.

    App layer example, 
        - Muliple clients ports in user space exits through socket API(attach socket to a cetain port number is the idea), TCP and IP in Kernel Space, Ethernet adapter in hardware. 
        - Same thing back up on serverside to single server.
    
    OSI/TCP Stack is an hourglass model. Because the intermediay layer is just 1 for internet layer, IP.

        - IP based on minimalist approach - DUMB NETWORK, switches, routers, just do store lookup and forward; routing, addressing, forwarding.
        - Transport layer and application layer controls more sophistacated(correctiness, congestion control, etc.) functionalities. - main job of internet is to pass things along.

        Advantages: accomodate heterogeneous tech(ethernet, wireless, satelline), support diverse apps(web, windows, ftp, telnet), decentralized network administration.
    
    Performance Analysis:
        Processing delay(sram access delay, string match for addr delay, etc.), queing delay (buffer delays in queue, time to wait to be transmitted),
        Transmission Delay (time to put info onto comms ports - port/transmission/link wire speed), Propagation Delay (time requred to propagate(wire to end host) over comms link.)
        Per node is also called total nodal delay, latency.

        Prop vs transmission delays: (propagation delay doesnt matter in close distance(but matters in long distance), transmisssion delays matter always).

        Round trip time, RTT: 2x one way latency ideally, but not always symmetric, the paths and latencies might not be same.
        Throughput: how many bits per second across 2 points in a network(file size/tranfer time), can only be min(or less) of two path speeds(input/output from switch/router), bottleneck.

        Total percieved delay = initial delay(how long it takes first packet to get from point a to b) + avg sustained throughput(Size/Data Rate).

            Throughput Sensive vs Delay/Latency Limited: if size is small/pings we are dominatied by latency(initial RTT), massive packets are dominated by avg sustained throughput. 
            - Applicatiion(data size) Dependent.

            - definitions of thoughput differs from layers and intent: 
                Can be application layer only data, app + headers, different headers, how measurements are done/load, how many flows(1-1 or 1-100), packet rate for data generation, etc.
                - retransmissions for dropped packets, first data measure or multiple, etc.
                The 4 delays are fixed though: the processing, queing, transmission, propagation delays.
        
            Bandwidth Delay Product: 
                Bandwidth: number of bits that can be sent instanteously, the circumference area of pipe.
                Delay - Length of pipe
                BDP: volume of pipe, the max number of bits that can transpit though pipe at given instant.
            
                RTT x Bandwidth = can approximate how much data we can pump into pipe and when to expect the data, to send + get confirmation.
                    - we pump data and if we get error we chaange, we dont send an initial packet and if it works we send(too slow i think).

                Network Tools, On Terminal:
                    traceroute (ip/DNS puclic address) - shows all route (might be blocked by ISP,spectrum, etc.)
                    ping (public website) - shows ping rates
                    netstat - all the tcp flows that are active, address, active, etc.
                    IFCONFIG?
                    sudo tcdump - allows you to acess packets at whatever fidelity, inpect network traffic (Wireshark open source analysis tool)
                
# LECTURE 4: Physical Layer
    Analog vs digital: analog takes continnous vals(sounds,images, etc.), digital takes discrete(texts, data, ex.), can convert bwt them.
        - analog data can be distorted when sent over network. digital easier, just checks between 0s and 1s. (if long distance data is still distorted, but we place regenerators to reamplify signal-to first sent like)
    digital nowadays: everything is a common abstraction towards bitstream. advantageous to be on single network.

    Modulation fundamentals(amplitude, feq, phase): bitstream over different mediams. ways to modulated waves, AM, PM,FM, amplitude Modulation, freq mod, phase mod (look into images to understand differences).         
        - does not have to be binary, can be muti-valued.

    Channel characterization(bandwidth,BER,SNR): how fast can we make perofrmance at bit stream level. can introduce, noise, attenuation, etc.
        - Bandwidth is the width of the freqncy range in which the fourier transform of the signal is non-zero. 
        (given any time signal, can convert to any number of feq sinosidual waves sum of which will be the orig time signal)
            doing this gives spectrum or freqency data, that allows us to measure bandwidth.(99% of energy seen on data amplitude, various scales(power,log)) db is half power, some scale.

        - Transmission Considerations ( Fundamental Limits: Nyquist limit, shannon limits)
            Limits: random energy (noise) always added to signal. Attenuation: some egery leaks away. Dispersion: attenuation + propagaion speed are freq dept(changes the shape of signal).
                - effects limit the data rate chanel can sustain, affects differnet trech in diff ways.
                - effects befome worse with distance. tradeoff between data rate and distance.
        
            Pulse transmission rate - channels turns digital signal to pulse(slightly spread out analog like shapes) Wc is the 99% of channel freq content. Up to 1-2Wc we can transmit without issues.
                if mlti level , 2^M amplitude levels bit rate = 2mWc(bit/pulse * 2Wc) bps, binary pulses bit rrate = 2Wc bps.

            Noise and Reliable Comms: physical systems have noise. create error, we report it though bit error rate (BER).
                SNR: signal to noise ratio, higher signal compared to noise = higher avg signal power. higher SNR = less errors. SNR decides if bit will be properly flipped when received.
                Nyquist limit - upper bound you can send through channel ideally. can past limit with multi-valued symbols, but SNR will ultimately decide limit. 
                    - Maximum possible capacity any noisy channel can supoprt: Capacity-bps, bandwith-hz, S/N-SNR, C = B * Log2(1+S/N) Shannons theorem. no one been able to do better than this.
                
                transmission rate(R) < C = arbitarily reliable comms is possible. R > C, then arb reliable comms is not possible.
                arb reliable means the BER can be made arb small though sufficiently complex coding.

            Bandpass channels: frequency centered at an fc point on wireless mediums(left is wc/2, same right), called carrier frequency. allows radios, telephones, and dsl models(not for wired).

# LECTURE 5: Physical Layer
    Digital Modulation 
        Baseband mod: send the bare signal - copper media, low feq(typically at 0 Hz).
        Carrier mod: use the signal to mod a higher feq signal, called a carerr. can send the signl in a particular particular part of the spectrum, i.e. wireless, radios, etc. (need to make space and move around freq channel.)
            how to do: amplitude career modulation, multiply digital voltage signal with career frequency to shift signal left or right on GHz channel, typical signal take small chunks in mHz. Creates twice the bandwidth, since mirrors on negative direction of shift as well.
            Implication of Carrier mod: Bandpass channel has bandwidth Wc, but due to mirror only 1/2 is useful. syetm suupports Wc but baseband challen has Wc/2 Hz available.
            Pros: idfferent users can use differnts part of channel, also known as frequency division multiplexing, though carreir modulation. (can be done by freq mod,phase mod, etc. - define fc,ft as locations)
        Demodualate-recover, by multiplying by 2cos(2pifct) for T seconds and low pass filtering(smoothing) - grabs the baseband signal discernable(from modulated carrer or baseband), and grab individual bitstream.
    line coding(wired): 
        Synchronizations of clocks in transmitters and recievers: but clock drift causes a loss of synchronization over a perod of time, even if both agree to freq due to hardware limitations. (True for wireless as well.)
        Asynchronous Transmission: 
            encoding converts binary to info seq into digital signal, sendedr then uses the digital signal tomodulate the sggnal in a way the reciever can recognize:
                - why need: synchronization issues, bit flips: error detection and correction, control symbols: start of end of bit seq/frame, electrical limits: avoid long seqs of ones or zeros.(all can be addressed via encoding - typically 1 level before phase feq/modulation)
            Line coding tech: 
                    naive Manchester Encoder: send both data and clock directions. issue: 2x electrical switches per bit. wasting two bits to send 1 bit of info.  (Also known as 1b/2b encoding, generall good no drift but inefficient)
                    Non Return to Zero: holds if same bit. sync loss due to lng seq of 1s or 0s, volt and clock can difts
                    NonReturn to Zero: every 1 switch, 0s holds sequence, sync loss due to long seq of 0s, increases number of electrcal switches per bit.

                    mBnB Encoding, m data bits are coded as symbols of n line bits(i.e. 4B5B - encode all 4 bits combinations to 5 bits that avoid long seqs and unique: can use 5bits, adv of clock drift and vold drift over time). Q: is it similar to manchester encoding?
                        gigabit over fiber uses - 8B/10B, 10Gigabit - 64B/66B.
    error control:
        workflow: (FEC - forward error correction)
            Transmitter: Bits to Fec to mod to signal.
            Reciever: signal to demod to fec to bits.
        Error Control: challens intro errors in digital comms, applications require certain reliability.
            ensures data stream is transmitted to certain level of accuracy despite rrors.
            two approaches: error retection and Retransmission(ARQ - resending data), Forward error correction(FEC - add extra data to correct as data psses along)
            can be done at multiple layer - wifi phy layer perform conv coding, etc.

        Key idea: data transmitted in blocks(codeblocks) to satisfy a pattern, no pattern then error. 
            can add extra bits to carry over info.
        
        Single Parity Check:
            - append a parity to k info bits, all codewords have even # of 1s. All eroors that create odd 1s are detectable as errors.
            - but if two flips happen, cannot detect. 
            Q: we are saying we can detect odd bit flips, what about more than 3 flips how to check/know? ignore?
                - just able to detect some i believe that become odd. even not detectable or even+odd just detects an error.
        
            - redundancy: some overhead to add bit.
            - all patterns with odd # of errors can be detected.
            - randon bit errors: many transmissions channels introduce bit errors at random indep of each other with some prob.
                we grab joint probabilities, if channel has p>=0.5 not worth wile to send over channel.
                Undetectable error: when even bit fits. n choose 4. number of other flips likelyhood gets smaller as it increases.

        what is good code? map by distance codewrods, if multiple valid/non-codewords codewords distributed somewhat uniformly its good, clustered of one kind might be getting confused.
            2D parity checks: we use row/col sums to detect, in number of 1s in row/col are even no error, odd errors?. 1,2,3 bit, errors can always be detected but patterns >4 can not be detected. 1bit errors can be detected and even corrected.
                check every rows and columns to see if count of 1s even or odd. then check if right and bottoms intersection is both odd, then error?
                cannot localize, just detect there is an error.
        checksum over intenet: to see calculation is equa to zero, can use modulo arithmetic but also binary.
    
    Q: confused about checksum, 2D checks, 1 bit detectable how if >2- just probability?
        - prob for how many bits are flipped.
        - checksum below
        - 2d checks if parity of extra row/col added at the end shows odd, then error. 1,2,3 detectable, 1 fixable. 

# LECTURE 6: 
    Other Error Detection Codes:
        Internet Checksum - inject known pattern, i.e. sequence even or sum of bits is 0, etc. for our case I.C. makes sum of bits is 0 by injecting an extra bit.
            checksum -*(adds all bits) mod (2^16 -1). add this back all bits, and sum mod 2^16 -1 should be 0. bit flips errorrs dont correct checksum.

        Cyclic redundancy Chekc(CRC) - for error detection though polynomial algebra.

        Repetition Code - Error correction code. sed repeated times and detection and correction by majority vote.
            High redundancy. adv codes(similar alts) - hamming, reed solomon, convolution codes, etc.

    QA Touch Base of past topics.
        - low pass filter, reduce freq of data, high pass allow more data to pass
        - bandpass channel, pass only a part of data, bandpass neg filter - take out a bandpass chunk of data.
        - rest edited into above notes.

    DataLink Layer:
        4 concepts - framing, switching, medium access control, reliable transmission.

        Frames:
            how we break up a stream of bits to frames(packets for higher level): a preamble + postamble (start/end token) + body.
            no minimum-can send smalle frames, but max above which need to be broken into multiple frames.

            Tech 1: Byte stuffing: sync markers, start header and start of text in preamble, postable end of text, checksum.
                sync markers might endin body, use escape character.
            Tech 2: Byte Counting: include a bute found and frame class in preamble to verify count in body if it matches. no start or end text marker.
                - but if counter bit is wrong-bitflip error, count wrong. checksum can detect and say if wrong though.
            Tech 3: Bit Stuffing: have a beg seq befor eheader, and end seq after crc. 
                add 0 for every 5 1's in body. receiver knows to see this pattern.
            Q: but how would we know if the seq had 5 origianlly or not? and how to detect ending, wont it just add 0?
                 - i supposed for end its after crc, so it would expect it after crc.
                 - count per bit sequence should be extra bits if bit 0 stuffed. (padding added in general to handle extra bits)

            
# LECTURE 7: DataLink Layer (Continued)

    Switching:
        ethernet - wired computer network technology.
        ethernet framing - does its own thing, preamble 8 bytes - separate technique than we studied. then eth Frame, then checksum(4b) at end. (error control happens everywere, data, physical, app, etc.)
            mac address - media access control 
            (6b and 6b for source and dest addr)
            type field (2b) used by payload follows, type specifies protol like ipv4
        switch has 2 stacks - max ability it can pass the data, is the data link layer. (has ports, addr lookup, traffic manager, que/buffer)
        table - if no match for addr will broadcast on all ports(except ones its coming from) - uses source addr and port so populates table. to make addr and port connections.
                - after tablel fill might be able to grab success hits. Only stores/looks up and forward.
                - ports just tell what is the next hops not final seq.
        switches need whole frame to come along.- classical
        cut-through switchnig - doesnt wait, if dest comes through and very low errors just pass it though.

        L2 Switching - enables scaling. 
        
        Forwarding Loop - waste when frames stuck in a look when trying to find sourceinit/dest.

        Spanning Tree Protocol(SPT) - convert cyclic graphs to trees. elect single switch as root switch. then travel to root then there is path to everywhere.
            - states kept at switch, another table(which know only their ids)
            - create a configuration message, to populate(imagine flood fill), root id, local id and distance to root. Keep issued periodically since things can happen(data lost, system down, etc.)
            - all switches when they start will think they are the root.
            (Switch operation assigns which switch has what id)
            - ACtions when recieve message - figure lowest number i.e.1 to assign root. communicate and find broadcast yes direction 
                - 2nd challenge path determination: resolve tiebreaks, make distance smaller, find root, disgrad everything else if not root. (most redundance link/edge/fartest connection determined though tiebreaker cut off - ports disables)
                    (i.e. switch 2 gets msg from sw1, finds sw1 id is less, adds dist +1 and stores with port number which it came from. if optimistic then broadcasts)
            



            
